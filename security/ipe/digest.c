// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

#include "digest.h"

/**
 * ipe_digest_parse - parse a digest in IPE's policy.
 * @valstr: Supplies the string parsed from the policy.
 *
 * Digests in IPE are defined in a standard way:
 *	<alg_name>:<hex>
 *
 * Use this function to create a property to parse the digest
 * consistently. The parsed digest will be saved in @value in IPE's
 * policy.
 *
 * Return: The parsed digest_info structure.
 */
struct digest_info *ipe_digest_parse(const char *valstr)
{
	char *sep, *raw_digest;
	size_t raw_digest_len;
	int rc = 0;
	char *alg = NULL;
	u8 *digest = NULL;
	struct digest_info *info = NULL;

	info = kzalloc(sizeof(*info), GFP_KERNEL);
	if (!info)
		return ERR_PTR(-ENOMEM);

	sep = strchr(valstr, ':');
	if (!sep) {
		rc = -EBADMSG;
		goto err;
	}

	alg = kstrndup(valstr, sep - valstr, GFP_KERNEL);
	if (!alg) {
		rc = -ENOMEM;
		goto err;
	}

	raw_digest = sep + 1;
	raw_digest_len = strlen(raw_digest);

	info->digest_len = (raw_digest_len + 1) / 2;
	digest = kzalloc(info->digest_len, GFP_KERNEL);
	if (!digest) {
		rc = -ENOMEM;
		goto err;
	}

	rc = hex2bin(digest, raw_digest, info->digest_len);
	if (rc < 0) {
		rc = -EINVAL;
		goto err;
	}

	info->alg = alg;
	info->digest = digest;
	return info;

err:
	kfree(alg);
	kfree(digest);
	kfree(info);
	return ERR_PTR(rc);
}

/**
 * ipe_digest_eval - evaluate an IPE digest against another digest.
 * @expected: Supplies the policy-provided digest value.
 * @digest: Supplies the digest to compare against the policy digest value.
 *
 * Return:
 * * true	- digests match
 * * false	- digests do not match
 */
bool ipe_digest_eval(const struct digest_info *expected,
		     const struct digest_info *digest)
{
	return (expected->digest_len == digest->digest_len) &&
	       (!strcmp(expected->alg, digest->alg)) &&
	       (!memcmp(expected->digest, digest->digest, expected->digest_len));
}

/**
 * ipe_digest_free - free an IPE digest.
 * @info: Supplies a pointer the policy-provided digest to free.
 */
void ipe_digest_free(struct digest_info *info)
{
	if (IS_ERR_OR_NULL(info))
		return;

	kfree(info->alg);
	kfree(info->digest);
	kfree(info);
}

/**
 * ipe_digest_audit - audit a digest that was sourced from IPE's policy.
 * @ab: Supplies the audit_buffer to append the formatted result.
 * @info: Supplies a pointer to source the audit record from.
 *
 * Digests in IPE are defined in a standard way:
 *	<alg_name>:<hex>
 *
 * Use this function to create a property to audit the digest
 * consistently.
 */
void ipe_digest_audit(struct audit_buffer *ab, const struct digest_info *info)
{
	audit_log_untrustedstring(ab, info->alg);
	audit_log_format(ab, ":");
	audit_log_n_hex(ab, info->digest, info->digest_len);
}

/**
 * ipe_digest_dup - Duplicate a digest_info structure.
 * @src: Pointer to the source digest_info structure.
 *
 * Return: A pointer to the duplicated digest or an ERR_PTR() in case of error.
 */
struct digest_info *ipe_digest_dup(const struct digest_info *src)
{
	struct digest_info *dup = NULL;
	char *alg_copy = NULL;
	u8 *digest_copy = NULL;

	if (IS_ERR_OR_NULL(src))
		return NULL;

	dup = kzalloc(sizeof(*dup), GFP_KERNEL);
	if (!dup)
		return ERR_PTR(-ENOMEM);

	alg_copy = kstrdup(src->alg, GFP_KERNEL);
	if (!alg_copy)
		goto err;

	digest_copy = kmemdup(src->digest, src->digest_len, GFP_KERNEL);
	if (!digest_copy)
		goto err;

	dup->alg = alg_copy;
	dup->digest = digest_copy;
	dup->digest_len = src->digest_len;

	return dup;

err:
	kfree(alg_copy);
	kfree(digest_copy);
	kfree(dup);
	return ERR_PTR(-ENOMEM);
}
